% 積木(block)
% MaskRay
% 2012年12月21日

## 考察點

惰性求值、隊列的函數式實現(馬蹄形雙棧)。

## 問題模型

需要支持隊列的三種操作，

- 爲已有的一個隊列創建一個複本。
- 在某個隊列頭部插入一個元素。
- 在某個隊列尾部刪除一個元素。

模擬算法能有效處理後兩種操作，但是無法勝任第一種操作。

## 隊列換成棧

如果把問題中的隊列改成棧，那麼可以用 Spaghetti stack，
對於“創建一個複本”，我們並不真的複製一份隊列，而是創建一個對原隊列的引用。
每一個引用用一個指向棧頂的指針來表示。
壓入元素時，創建一個 cons cell $(new_elem . old_stack)$，即新元素，和指向舊棧的指針。
彈出元素時，解開舊棧的 cons cell $(e . s)$，新棧的表示就是 $s$。

通過這種方式，新棧和舊棧的絕大多數元素都共用了，免去了耗時的全拷貝操作。

## 回到原問題

隊列不能簡單地用棧的表示發，$(old_queue . new_elem)$ 原因在於隊列的頭部可能會發生變化。
設想舊隊列的頭部刪除了一個元素，那麼新隊列由於復用了這個引用，也會收到影響，而實際上新隊列不應該發生改變。

函數式隊列的經典實現方式是使用馬蹄形的兩個棧，具體實現細節略過。從隊首刪除元素時，雙棧的第一個棧
可能爲空而發生和第二個棧的 reverse 的拼接操作，這一步可能非常耗時。如果測試數據一直對這樣的隊列執行彈出操作，
那麼時間複雜度就可能達到平方階。

## 雙棧實現的隊列的彈出操作

我們需要的是 `real-time queue`，即任何操作都得保證是 O(1) 的，而不是平攤 O(1) (原始的馬蹄形雙棧實現就屬於此類)。
這樣，馬蹄形雙棧中最費時的操作：把一個棧翻轉和另一個棧拼接的操作的代價得分攤到
其他各次操作上。一種實現方式是當 rear 棧的長度超過 fore 棧的長度時就實施翻轉和拼接操作。

不考慮一些邊界情況，核心操作如下(Haskell)：

  make [] rs acc = reverse rs ++ acc
  make (f:fs) (r:rs) acc = f : make fs rs (r:acc)

注意遞歸調用的 `make` 不能立刻執行，而要拖延到必須產生列表的頭元素爲止。

採用 lazy evaluation 後，已經能做到最壞情況下操作費時 O(log n) 了，可以解決本問題。

## 線性算法

採用一些技術可以把時間複雜度進一步降至 O(1)。`src/author/solution.cc` 和 `src/author/solution.hs` 實現了該算法。

## 另一種算法

另外有一個比上述 functional real-time queue 易於理解的算法。如果不考慮刪除操作，所有創建的棧可以形成的個樹結構。
而帶上刪除操作時，就相當於每個節點都有個標記，表示從它開始向上多少個元素是實際存在與隊列中的。詢問操作即返回某一號祖先。

可以使用求解 least common ancestor 時用的一種算法：每個節點記錄 2^k 號祖先。空間、時間複雜度 O(n log n)。
